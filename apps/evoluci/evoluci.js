// Generated by CoffeeScript 1.6.3
var ContextWrapper, InfHistory, Infanino, MenuItem, bearInf, checkFlag, checkMission, checkMissionOf, checkWebstorage, createEffect, createInf, createInfRnd, createNewInfaninos, draw, drawImpl, drawInfo, drawMenu, drawMessage, drawMissions, each, every, evolInf, filter, find, gameLoop, getDirection, getDistance, getInfName, getSumnOfParents, hittestRectangle, images, inclimentBirth, init, initCanvas, killInf, loadImages, moveInf, moveInfs, movePt, params, pushMessage, random, rnd, rndPL, setInfType, typeDef, update, updateClickEvent, updateMenu, __, _drawOrder, _menu, _missions;

each = _.each;

random = _.random;

filter = _.filter;

find = _.find;

every = _.every;

rnd = function(num) {
  return Math.floor(Math.random() * num);
};

rndPL = function() {
  return 1 - 2 * rnd(2);
};

getDistance = function(pt1, pt2) {
  return Math.sqrt(Math.pow(pt1.x - pt2.x, 2) + Math.pow(pt1.y - pt2.y, 2));
};

getDirection = function(pt1, pt2) {
  return Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x);
};

movePt = function(pt, drct, dist) {
  pt.x += dist * Math.cos(drct);
  return pt.y += dist * Math.sin(drct);
};

getSumnOfParents = function(obj, getValue, getParent) {
  var sum;
  sum = 0;
  while (obj) {
    sum += getValue(obj);
    obj = getParent(obj);
  }
  return sum;
};

hittestRectangle = function(pt1, pt2, distance) {
  return Math.abs(pt1.x - pt2.x) < distance && Math.abs(pt1.y - pt2.y) < distance;
};

Infanino = (function() {
  function Infanino(point, flag) {
    this.point = point;
    this.flag = flag;
    this.type = "tt";
    this.life = 100;
    this.energy = 1;
    this.arg = Math.random(2 * Math.PI);
    this.dArg = 0;
  }

  return Infanino;

})();

InfHistory = (function() {
  function InfHistory(id) {
    this.id = id;
    this.birth = 0;
    this.hungryDeath = 0;
    this.eatenDeath = 0;
    this.bombDeath = 0;
  }

  return InfHistory;

})();

ContextWrapper = (function() {
  function ContextWrapper(offset) {
    this.offset = offset;
  }

  ContextWrapper.prototype.setCtx = function(ctx) {
    this.ctx = ctx;
  };

  ContextWrapper.prototype.moveTo = function(pt) {
    return this.ctx.moveTo(pt.x + this.offset.x, pt.y + this.offset.y);
  };

  ContextWrapper.prototype.circle = function(pt, r) {
    this.ctx.moveTo(pt.x + r, pt.y);
    return this.ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2, false);
  };

  ContextWrapper.prototype.rect = function(left, right, top, floor) {
    return this.ctx.rect(left + this.offset.x, top + this.offset.y, right + this.offset.x, floor + this.offset.y);
  };

  ContextWrapper.prototype.drawImage = function(img, pt) {
    if (img !== null) {
      return this.ctx.drawImage(img, pt.x - img.width / 2, pt.y - img.height / 2);
    }
  };

  return ContextWrapper;

})();

MenuItem = (function() {
  function MenuItem(index, checked, id) {
    this.checked = checked;
    this.id = id;
    this.point = {
      x: params.screanWidth - params.menuTileSize * (index * 2 + 1) / 2,
      y: params.screanHeight - params.menuTileSize / 2 - 30
    };
  }

  return MenuItem;

})();

params = {
  screanWidth: 640,
  screanHeight: 480,
  infaninos_max: 1800,
  interval: 30,
  stop: false,
  clickType: "bomb",
  pick: null,
  marginLeft: 5,
  marginTop: 5,
  marginRight: 150,
  marginBottom: 65,
  menuTileSize: 40
};

params.scrLeft = params.marginLeft;

params.scrRight = params.screanWidth - params.marginLeft - params.marginRight;

params.scrTop = params.marginTop;

params.scrFloor = params.screanHeight - params.marginTop - params.marginBottom;

__ = {
  info: {
    time: 0,
    bombNum: 0
  },
  infaninos: null,
  infHistory: {},
  missionFlag: {},
  canvas: null,
  ctxWrap: null,
  mouse: {
    clicked: false,
    pt: {
      x: 0,
      y: 0
    }
  },
  message: [],
  currentMessage: null,
  livingInfaninos: null,
  livingInfLists: null,
  deadInfs: null,
  effects: [],
  objects: [],
  energy: 0
};

_menu = {
  save: new MenuItem(1, false, "save"),
  load: new MenuItem(0, false, "load"),
  watch: new MenuItem(5, true, "watch"),
  data: new MenuItem(4, false, "data"),
  mission: new MenuItem(3, false, "mission"),
  stop: new MenuItem(9, false, "stop"),
  play: new MenuItem(8, true, "play"),
  hispeed: new MenuItem(7, false, "hispeed"),
  pincettes: new MenuItem(12, false, "pincettes"),
  bomb: new MenuItem(11, true, "bomb")
};

_menu.data.index = -1;

_missions = [
  {
    name: "生物博士",
    getCondition: function() {
      return "全ての生き物を発生させる";
    }
  }, {
    name: "爆撃魔神",
    getCondition: function() {
      return "爆撃で1000体生物を殺す";
    }
  }, {
    name: "ベテラン",
    getCondition: function() {
      return "時間が100000に達する";
    }
  }, {
    name: "森林浴",
    getCondition: function() {
      return "" + (getInfName("ki")) + " を50体以上にする";
    }
  }, {
    name: "サバンナ",
    getCondition: function() {
      return "" + (getInfName("ks")) + " を200体以上, " + (getInfName("on")) + " を5体以上にする";
    }
  }, {
    name: "お花畑",
    getCondition: function() {
      return "" + (getInfName("hn")) + " を100体以上にする";
    }
  }, {
    name: "鳥天国",
    getCondition: function() {
      return "" + (getInfName("tr")) + " を20体以上, " + (getInfName("kt")) + " を10体以上にする";
    }
  }, {
    name: "毒の大地",
    getCondition: function() {
      return "" + (getInfName("db")) + "を300体以上にする";
    }
  }, {
    name: "奈良",
    getCondition: function() {
      return "" + (getInfName("sd")) + "を30体以上にする";
    }
  }, {
    name: "吸血地獄",
    getCondition: function() {
      return "" + (getInfName("ka")) + "を50体以上にする";
    }
  }, {
    name: "海辺の生物",
    getCondition: function() {
      return "" + (getInfName("yk")) + ", " + (getInfName("hd")) + ", " + (getInfName("km")) + " を同時に出現させる";
    }
  }, {
    name: "緑一色",
    getCondition: function() {
      return "フィールドの生物を " + (getInfName("sb")) + ", " + (getInfName("sm")) + ", " + (getInfName("ks")) + ", " + (getInfName("km")) + ", " + (getInfName("hb")) + " だけにする";
    }
  }, {
    name: "多様性",
    getCondition: function() {
      return "同時に10種類以上の生物を存在させる";
    }
  }, {
    name: "虫イーター",
    getCondition: function() {
      return "" + (getInfName("nm")) + ", " + (getInfName("sm")) + "を200体以上捕食する";
    }
  }, {
    name: "殻割名人",
    getCondition: function() {
      return "" + (getInfName("yk")) + "を1000体以上捕食する";
    }
  }, {
    name: "森林伐採",
    getCondition: function() {
      return "" + (getInfName("ki")) + "を500体以上捕食する";
    }
  }, {
    name: "プロポリス",
    getCondition: function() {
      return "" + (getInfName("ht")) + "を10体以上捕食する";
    }
  }, {
    name: "高級食材",
    getCondition: function() {
      return "" + (getInfName("kk")) + "を捕食する";
    }
  }, {
    name: "大好物",
    getCondition: function() {
      return "" + (getInfName("sa")) + "を捕食する";
    }
  }, {
    name: "命の源",
    getCondition: function() {
      return "" + (getInfName("nb")) + "の出生数を2000000以上にする";
    }
  }
];

getInfName = function(type) {
  if (__.infHistory[type].birth > 0) {
    return typeDef[type].name;
  } else {
    return "？？？";
  }
};

typeDef = {
  tt: {
    index: 0,
    id: "tt",
    name: "土",
    lifeTime: 100,
    energy: 1,
    limit: 1,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "lifeEnd",
      range: 10
    },
    evolution: [
      {
        id: "nb",
        probability: 1500,
        num: 6
      }
    ],
    eatDef: {
      range: 0,
      hungry: 0
    },
    eat: [],
    decompose: []
  },
  nb: {
    index: 1,
    id: "nb",
    name: "動物性微生物",
    lifeTime: 500,
    energy: 1,
    limit: 1,
    moveDef: {
      speed: 0.7,
      dArg: 1
    },
    breed: {
      type: "split",
      time: 120,
      range: 5
    },
    evolution: [
      {
        id: "nm",
        probability: 50
      }, {
        id: "hd",
        probability: 30000
      }, {
        id: "sb",
        type: "eaten",
        probability: 100
      }, {
        id: "db",
        type: "eaten",
        probability: 30000
      }
    ],
    eatDef: {
      range: 5,
      hungry: 2
    },
    eat: [
      {
        id: "tt",
        probability: 4
      }
    ],
    decompose: []
  },
  nm: {
    index: 2,
    id: "nm",
    name: "肉食虫",
    lifeTime: 350,
    energy: 2,
    limit: 0.05,
    moveDef: {
      speed: 2.5,
      dArg: 2.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "sm",
        type: "hungry",
        probability: 20,
        key: "sb"
      }, {
        id: "kn",
        probability: 100
      }, {
        id: "ht",
        type: "eaten",
        probability: 3000
      }
    ],
    eatDef: {
      range: 6,
      hungry: 4
    },
    eat: [
      {
        id: "nb",
        probability: 3
      }, {
        id: "sa",
        probability: 80
      }, {
        id: "sm",
        probability: 100
      }, {
        id: "ka",
        probability: 100
      }
    ],
    decompose: []
  },
  kn: {
    index: 3,
    id: "kn",
    name: "小型肉食動物",
    lifeTime: 550,
    energy: 3,
    limit: 0.03,
    moveDef: {
      speed: 2,
      dArg: 2
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "on",
        probability: 350
      }, {
        id: "sd",
        probability: 2000,
        key: "ki"
      }, {
        id: "hb",
        type: "hungry",
        probability: 20
      }
    ],
    eatDef: {
      range: 6,
      hungry: 6
    },
    eat: [
      {
        id: "nm",
        probability: 3,
        life: 70
      }, {
        id: "sm",
        probability: 3,
        life: 70
      }, {
        id: "tr",
        probability: 200,
        life: 70
      }, {
        id: "yk",
        probability: 200,
        life: 70
      }, {
        id: "nb",
        probability: 300,
        life: 70
      }
    ],
    decompose: ["nb", "tt"]
  },
  sb: {
    index: 4,
    id: "sb",
    name: "植物性微生物",
    lifeTime: 500,
    energy: 1,
    limit: 1,
    moveDef: {
      speed: 0.7,
      dArg: 1
    },
    eatDef: {
      range: 5,
      hungry: 2
    },
    breed: {
      type: "split",
      time: 120,
      range: 5
    },
    evolution: [
      {
        id: "sm",
        probability: 20
      }, {
        id: "ks",
        probability: 200
      }, {
        id: "sa",
        type: "eaten",
        probability: 8000
      }
    ],
    eat: [
      {
        id: "tt",
        probability: 4
      }
    ],
    decompose: []
  },
  sm: {
    index: 5,
    id: "sm",
    name: "草食虫",
    lifeTime: 350,
    energy: 2,
    limit: 0.05,
    moveDef: {
      speed: 2.5,
      dArg: 2.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "nm",
        type: "hungry",
        probability: 20
      }, {
        id: "tr",
        probability: 400,
        key: "ki"
      }, {
        id: "ka",
        probability: 2000,
        key: "kn"
      }, {
        id: "yk",
        type: "hungry",
        probability: 3000
      }, {
        id: "yk",
        type: "eaten",
        probability: 2500
      }
    ],
    eatDef: {
      range: 6,
      hungry: 4
    },
    eat: [
      {
        id: "sb",
        probability: 3
      }, {
        id: "ks",
        probability: 3
      }, {
        id: "hn",
        probability: 3
      }, {
        id: "ki",
        type: "mos",
        probability: 100
      }
    ],
    decompose: ["sb", "tt"]
  },
  ki: {
    index: 6,
    id: "ki",
    name: "木",
    lifeTime: 900,
    energy: 2,
    limit: 1,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "split",
      time: 400,
      range: 50
    },
    evolution: [
      {
        id: "kb",
        probability: 100
      }, {
        id: "kk",
        type: "eaten",
        probability: 1000
      }
    ],
    eatDef: {
      range: 8,
      hungry: 4
    },
    eat: [
      {
        id: "tt",
        probability: 3,
        life: 150
      }, {
        id: "sb",
        probability: 3,
        life: 150
      }
    ],
    decompose: ["sb", "tt"]
  },
  tr: {
    index: 7,
    id: "tr",
    name: "鳥",
    lifeTime: 600,
    energy: 3,
    limit: 0.015,
    moveDef: {
      speed: 2,
      dArg: 0.7
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "kt",
        probability: 1000
      }
    ],
    eatDef: {
      range: 6,
      hungry: 6
    },
    eat: [
      {
        id: "nm",
        probability: 15,
        life: 80
      }, {
        id: "sm",
        probability: 20,
        life: 80
      }, {
        id: "sa",
        probability: 20,
        life: 80
      }, {
        id: "ht",
        probability: 20,
        life: 80
      }, {
        id: "ka",
        probability: 50,
        life: 80
      }
    ],
    decompose: ["sb", "nb", "tt"]
  },
  kb: {
    index: 8,
    id: "kb",
    name: "巨木",
    lifeTime: 5000,
    energy: 10,
    limit: 1,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "non",
      range: 50
    },
    evolution: [],
    eatDef: {
      range: 20,
      hungry: 20
    },
    eat: [
      {
        id: "tt",
        probability: 10,
        life: 100
      }, {
        id: "sb",
        probability: 50,
        life: 100
      }
    ],
    decompose: ["sb", "tt"]
  },
  on: {
    index: 9,
    id: "on",
    name: "大型肉食動物",
    lifeTime: 850,
    energy: 7,
    limit: 0.007,
    moveDef: {
      speed: 2,
      dArg: 1
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [],
    eatDef: {
      range: 8,
      hungry: 14
    },
    eat: [
      {
        id: "kn",
        probability: 4,
        life: 80
      }, {
        id: "sd",
        probability: 4,
        life: 80
      }, {
        id: "ak",
        probability: 4,
        life: 80
      }, {
        id: "yk",
        probability: 8,
        life: 80
      }, {
        id: "tr",
        probability: 10,
        life: 80
      }, {
        id: "kt",
        probability: 50,
        life: 80
      }
    ],
    decompose: ["nb", "tt"]
  },
  ka: {
    index: 10,
    id: "ka",
    name: "蚊",
    lifeTime: 500,
    energy: 1,
    limit: 0.1,
    moveDef: {
      speed: 2,
      dArg: 2
    },
    breed: {
      type: "split",
      time: 120,
      range: 5
    },
    evolution: [],
    eatDef: {
      range: 5,
      hungry: 2
    },
    eat: [
      {
        id: "kn",
        probability: 4,
        type: "mos"
      }, {
        id: "sd",
        probability: 4,
        type: "mos"
      }, {
        id: "ak",
        probability: 4,
        type: "mos"
      }, {
        id: "on",
        probability: 4,
        type: "mos"
      }, {
        id: "tr",
        probability: 4,
        type: "mos"
      }, {
        id: "kt",
        probability: 4,
        type: "mos"
      }
    ],
    decompose: ["tt"]
  },
  yk: {
    index: 11,
    id: "yk",
    name: "ヤドカリ",
    lifeTime: 500,
    energy: 2,
    limit: 0.03,
    moveDef: {
      speed: 1.2,
      dArg: 2
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "km",
        probability: 9000
      }, {
        id: "sm",
        probability: 200
      }, {
        id: "nm",
        probability: 200
      }
    ],
    eatDef: {
      range: 8,
      hungry: 4
    },
    eat: [
      {
        id: "sb",
        probability: 15
      }, {
        id: "ks",
        probability: 100,
        type: "mos"
      }, {
        id: "hn",
        probability: 100
      }, {
        id: "db",
        probability: 150
      }
    ],
    decompose: ["sb", "nb", "tt"]
  },
  hd: {
    index: 12,
    id: "hd",
    name: "ヒトデ",
    lifeTime: 800,
    energy: 2,
    limit: 0.03,
    moveDef: {
      speed: 1,
      dArg: 1
    },
    breed: {
      type: "split",
      time: 300,
      range: 5
    },
    evolution: [],
    eatDef: {
      range: 6,
      hungry: 4
    },
    eat: [
      {
        id: "nb",
        probability: 3
      }, {
        id: "db",
        probability: 3
      }, {
        id: "sb",
        probability: 3
      }
    ],
    decompose: ["nb", "tt"]
  },
  hn: {
    index: 13,
    id: "hn",
    name: "花",
    lifeTime: 500,
    energy: 1,
    limit: 1,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "split",
      time: 200,
      range: 15
    },
    evolution: [],
    eatDef: {
      range: 8,
      hungry: 2
    },
    eat: [
      {
        id: "tt",
        probability: 3
      }, {
        id: "sb",
        probability: 10
      }
    ],
    decompose: ["sb", "tt"]
  },
  km: {
    index: 14,
    id: "km",
    name: "亀",
    lifeTime: 2500,
    energy: 4,
    limit: 0.008,
    moveDef: {
      speed: 0.5,
      dArg: 0.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [],
    eatDef: {
      range: 6,
      hungry: 8
    },
    eat: [
      {
        id: "hd",
        probability: 3,
        life: 100
      }, {
        id: "hb",
        probability: 3,
        life: 100
      }, {
        id: "yk",
        probability: 50,
        life: 100
      }, {
        id: "ks",
        probability: 5,
        type: "mos"
      }, {
        id: "ki",
        probability: 5,
        type: "mos"
      }, {
        id: "kk",
        probability: 100,
        type: "mos"
      }
    ],
    decompose: ["nb", "sb", "tt"]
  },
  kt: {
    index: 15,
    id: "kt",
    name: "巨鳥",
    lifeTime: 800,
    energy: 4,
    limit: 0.005,
    moveDef: {
      speed: 3,
      dArg: 0.6
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [],
    eatDef: {
      range: 6,
      hungry: 9
    },
    eat: [
      {
        id: "nm",
        probability: 10,
        life: 80
      }, {
        id: "sm",
        probability: 10,
        life: 80
      }, {
        id: "hb",
        probability: 50,
        life: 70
      }, {
        id: "tr",
        probability: 100,
        life: 150
      }, {
        id: "yk",
        probability: 100,
        life: 150
      }
    ],
    decompose: ["nb", "sb", "tt"]
  },
  db: {
    index: 16,
    id: "db",
    name: "毒性微生物",
    lifeTime: 2000,
    energy: 1,
    limit: 0.15,
    moveDef: {
      speed: 0.4,
      dArg: 1
    },
    eatDef: {
      range: 4,
      hungry: 2
    },
    breed: {
      type: "split",
      time: 1200,
      range: 2
    },
    evolution: [],
    eat: [
      {
        id: "tt",
        probability: 4
      }
    ],
    decompose: []
  },
  ks: {
    index: 17,
    id: "ks",
    name: "草",
    lifeTime: 500,
    energy: 1,
    limit: 1,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "split",
      time: 110,
      range: 45
    },
    evolution: [
      {
        id: "ki",
        probability: 100
      }, {
        id: "hn",
        probability: 10000
      }, {
        id: "ss",
        type: "eaten",
        probability: 1000
      }
    ],
    eatDef: {
      range: 7,
      hungry: 2
    },
    eat: [
      {
        id: "tt",
        probability: 3
      }, {
        id: "sb",
        probability: 10
      }
    ],
    decompose: ["sb"]
  },
  sd: {
    index: 18,
    id: "sd",
    name: "草食動物",
    lifeTime: 600,
    energy: 4,
    limit: 0.03,
    moveDef: {
      speed: 3,
      dArg: 2.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "on",
        probability: 300
      }
    ],
    eatDef: {
      range: 6,
      hungry: 8
    },
    eat: [
      {
        id: "ks",
        probability: 3,
        life: 30
      }, {
        id: "ss",
        probability: 5,
        life: 30
      }, {
        id: "ki",
        probability: 50,
        life: 30
      }, {
        id: "sm",
        probability: 100,
        life: 30
      }, {
        id: "kk",
        probability: 100,
        life: 30
      }
    ],
    decompose: ["nb", "sb", "tt"]
  },
  ak: {
    index: 19,
    id: "ak",
    name: "アリクイ",
    lifeTime: 500,
    energy: 3,
    limit: 0.03,
    moveDef: {
      speed: 2,
      dArg: 1.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "sd",
        probability: 200,
        key: "ki"
      }, {
        id: "ma",
        probability: 2000
      }
    ],
    eatDef: {
      range: 6,
      hungry: 6
    },
    eat: [
      {
        id: "sa",
        probability: 3,
        life: 10
      }, {
        id: "nb",
        probability: 30,
        life: 10
      }, {
        id: "nm",
        probability: 100,
        life: 10
      }
    ],
    decompose: ["tt", "nb", "sb"]
  },
  sa: {
    index: 20,
    id: "sa",
    name: "シロアリ",
    lifeTime: 500,
    energy: 1,
    limit: 1,
    moveDef: {
      speed: 0.9,
      dArg: 1
    },
    breed: {
      type: "split",
      time: 200,
      range: 5
    },
    evolution: [
      {
        id: "ak",
        probability: 2000
      }
    ],
    eatDef: {
      range: 5,
      hungry: 2
    },
    eat: [
      {
        id: "ks",
        probability: 3
      }, {
        id: "hn",
        probability: 3
      }, {
        id: "sb",
        probability: 10
      }, {
        id: "ki",
        probability: 50,
        type: "mos"
      }, {
        id: "nb",
        probability: 100
      }
    ],
    decompose: []
  },
  kk: {
    index: 21,
    id: "kk",
    name: "キノコ",
    lifeTime: 650,
    energy: 2,
    limit: 0.1,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "split",
      time: 200,
      range: 50
    },
    evolution: [
      {
        id: "ki",
        probability: 100
      }
    ],
    eatDef: {
      range: 10,
      hungry: 4
    },
    eat: [
      {
        id: "tt",
        probability: 3
      }, {
        id: "db",
        probability: 3
      }, {
        id: "sb",
        probability: 100
      }, {
        id: "ki",
        probability: 200,
        type: "mos"
      }
    ],
    decompose: ["sb", "nb"]
  },
  ma: {
    index: 22,
    id: "ma",
    name: "クマ",
    lifeTime: 850,
    energy: 5,
    limit: 0.005,
    moveDef: {
      speed: 1.5,
      dArg: 1.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "sd",
        probability: 1000
      }
    ],
    eatDef: {
      range: 5,
      hungry: 10
    },
    eat: [
      {
        id: "hb",
        probability: 3,
        life: 70
      }, {
        id: "ht",
        probability: 3,
        life: 70
      }, {
        id: "yk",
        probability: 3,
        life: 70
      }, {
        id: "kn",
        probability: 30,
        life: 70
      }, {
        id: "kk",
        probability: 50,
        life: 70
      }, {
        id: "ss",
        probability: 100,
        life: 70
      }, {
        id: "tt",
        probability: 100,
        life: 70
      }, {
        id: "ak",
        probability: 200,
        life: 70
      }
    ],
    decompose: ["sb", "nb"]
  },
  hb: {
    index: 23,
    id: "hb",
    name: "ヘビ",
    lifeTime: 500,
    energy: 3,
    limit: 0.03,
    moveDef: {
      speed: 1.5,
      dArg: 1.5
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [
      {
        id: "kn",
        probability: 100
      }
    ],
    eatDef: {
      range: 5,
      hungry: 6
    },
    eat: [
      {
        id: "nm",
        probability: 3,
        life: 20
      }, {
        id: "sm",
        probability: 3,
        life: 20
      }, {
        id: "kn",
        probability: 100,
        life: 20
      }, {
        id: "hd",
        probability: 100,
        life: 20
      }
    ],
    decompose: []
  },
  ht: {
    index: 24,
    id: "ht",
    name: "ハチ",
    lifeTime: 350,
    energy: 3,
    limit: 0.03,
    moveDef: {
      speed: 3,
      dArg: 3
    },
    breed: {
      type: "lifeEnd",
      range: 5
    },
    evolution: [],
    eatDef: {
      range: 5,
      hungry: 6
    },
    eat: [
      {
        id: "nb",
        probability: 5
      }, {
        id: "sa",
        probability: 30
      }, {
        id: "ka",
        probability: 100,
        life: 20
      }, {
        id: "nm",
        probability: 100,
        life: 20
      }, {
        id: "sm",
        probability: 100,
        life: 20
      }
    ],
    decompose: ["nb"]
  },
  ss: {
    index: 25,
    id: "ss",
    name: "食虫植物",
    lifeTime: 600,
    energy: 2,
    limit: 0.03,
    moveDef: {
      speed: 0,
      dArg: 0
    },
    breed: {
      type: "lifeEnd",
      range: 50
    },
    evolution: [],
    eatDef: {
      range: 9,
      hungry: 4
    },
    eat: [
      {
        id: "sa",
        probability: 5
      }, {
        id: "nm",
        probability: 5
      }, {
        id: "sm",
        probability: 5
      }, {
        id: "ht",
        probability: 5
      }, {
        id: "tt",
        probability: 5
      }
    ],
    decompose: []
  }
};

images = null;

_drawOrder = ["tt", "sb", "nb", "db", "sa", "ks", "hn", "ss", "kk", "hd", "sm", "nm", "yk", "kn", "hb", "km", "ak", "sd", "ma", "on", "ki", "kb", "ka", "ht", "tr", "kt"];

init = function(canvas) {
  var livingInfLists;
  __.canvas = initCanvas(canvas);
  __.ctxWrap = new ContextWrapper({
    x: params.marginLeft,
    y: params.marginTop
  });
  each(typeDef, function(typeParams) {
    return __.infHistory[typeParams.id] = new InfHistory(typeParams.id);
  });
  __.infaninos = createNewInfaninos();
  __.message = [];
  loadImages();
  livingInfLists = {};
};

initCanvas = function(canvas) {
  var mouseOffsetX, mouseOffsetY;
  canvas.width = params.screanWidth;
  canvas.height = params.screanHeight;
  window.onclick = function(e) {
    __.mouse.clicked = true;
    __.mouse.pt.x = e.pageX - mouseOffsetX;
    return __.mouse.pt.y = e.pageY - mouseOffsetY;
  };
  mouseOffsetX = getSumnOfParents(canvas, function(obj) {
    return obj.offsetLeft;
  }, function(obj) {
    return obj.offsetParent;
  });
  mouseOffsetY = getSumnOfParents(canvas, function(obj) {
    return obj.offsetTop;
  }, function(obj) {
    return obj.offsetParent;
  });
  window.onmousemove = function(e) {
    __.mouse.pt.x = e.pageX - mouseOffsetX;
    return __.mouse.pt.y = e.pageY - mouseOffsetY;
  };
  return canvas;
};

createNewInfaninos = function() {
  var i, inf, pt, _i, _ref, _results;
  _results = [];
  for (i = _i = 0, _ref = params.infaninos_max; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    pt = {
      x: params.marginLeft + rnd(params.screanWidth - 2 * params.marginLeft - params.marginRight),
      y: params.marginTop + rnd(params.screanHeight - 2 * params.marginTop - params.marginBottom)
    };
    inf = new Infanino(pt, true);
    setInfType(inf, "tt");
    _results.push(inf);
  }
  return _results;
};

loadImages = function() {
  var loadImg;
  loadImg = function(id) {
    var result;
    result = new Image();
    result.src = "images/" + id + ".png";
    images[id] = result;
  };
  images = [];
  each(typeDef, function(typeParams) {
    return loadImg(typeParams.id);
  });
  return each(_menu, function(menuitem) {
    return loadImg(menuitem.id);
  });
};

draw = function() {
  var ctx, ctxDrawProcess;
  if (__.livingInfLists === null) {
    return;
  }
  ctx = __.canvas.getContext('2d');
  ctx.clearRect(0, 0, params.screanWidth, params.screanHeight);
  ctx.strokeStyle = 'rgb(150, 240, 240)';
  ctx.lineWidth = 3;
  ctxDrawProcess = function(predicate) {
    ctx.beginPath();
    predicate();
    ctx.closePath();
    return ctx.stroke();
  };
  ctxDrawProcess(function() {
    return ctx.rect(0, 0, params.screanWidth, params.screanHeight);
  });
  ctx.lineWidth = 1;
  __.ctxWrap.setCtx(ctx);
  if (_menu.mission.checked) {
    drawMissions();
  } else {
    ctxDrawProcess(drawImpl);
  }
  ctxDrawProcess(function() {
    drawInfo(ctx);
    return drawMenu();
  });
  ctxDrawProcess(drawMessage);
};

drawInfo = function(ctx) {
  var birthTotal, bombDeath, eatMenu, eatTotal, hist, hungryDeath, indent, lineCount, startX, temp, typeParams, write, writeheading, writeline, _i, _j, _len, _len1, _ref, _ref1;
  ctx.font = "12px 'ＭＳ ゴシック'";
  ctx.fillStyle = "rgb(150, 240, 240)";
  startX = params.screanWidth - params.marginRight;
  write = function(str) {
    return ctx.fillText(str, startX, 14 * lineCount + params.marginTop);
  };
  writeline = function(str) {
    return ctx.fillText(str, startX, 14 * lineCount++ + params.marginTop);
  };
  writeheading = function(str) {
    ctx.fillText(str, startX, 14 * lineCount + params.marginTop);
    return lineCount += 1.5;
  };
  indent = function(str) {
    return "               " + str;
  };
  lineCount = 1;
  if (_menu.watch.checked) {
    write("  時間");
    writeline(indent(" " + __.info.time));
    startX += 10;
    lineCount++;
    return each(typeDef, function(typeParams) {
      write("  " + (getInfName(typeParams.id)));
      if (__.infHistory[typeParams.id].birth) {
        __.ctxWrap.drawImage(images[typeParams.id], {
          x: startX,
          y: 14 * lineCount
        });
      }
      return writeline(indent("" + __.livingInfLists[typeParams.id].length));
    });
  } else if (_menu.data.checked) {
    typeParams = find(typeDef, function(typeParams) {
      return typeParams.index === _menu.data.index;
    });
    if (typeParams) {
      hist = __.infHistory[typeParams.id];
      writeline(" □ " + (getInfName(typeParams.id)) + " □");
      lineCount++;
      writeheading(" ●主食");
      _ref = filter(typeParams.eat, function(eatMenu) {
        return eatMenu.probability < 100;
      });
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        eatMenu = _ref[_i];
        writeline("  " + (getInfName(eatMenu.id)));
      }
      lineCount++;
      temp = 0;
      writeheading(" ●たまに食べる");
      _ref1 = filter(typeParams.eat, function(eatMenu) {
        return eatMenu.probability >= 100;
      });
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        eatMenu = _ref1[_j];
        writeline("  " + (getInfName(eatMenu.id)));
        temp++;
      }
      if (temp === 0) {
        writeline("  なし");
      }
      lineCount++;
      temp = 0;
      writeheading(" ●捕食生物");
      each(typeDef, function(anotherTypeParams) {
        if (find(anotherTypeParams.eat, function(eatMenu) {
          return eatMenu.id === typeParams.id;
        })) {
          writeline("  " + (getInfName(anotherTypeParams.id)));
          temp++;
        }
      });
      if (temp === 0) {
        writeline("  なし");
      }
      lineCount++;
      writeheading(" ★ 記録 ★");
      write("  出生回数");
      writeline(indent("" + hist.birth));
      write("  餓死回数");
      writeline(indent("" + hist.hungryDeath));
      write("  捕食死回数");
      writeline(indent("" + hist.eatenDeath));
      write("  爆撃死回数");
      return writeline(indent("" + hist.bombDeath));
    } else {
      writeheading(" ★ 色々な記録 ★");
      _menu.data.index = -1;
      birthTotal = 0;
      eatTotal = 0;
      hungryDeath = 0;
      bombDeath = 0;
      each(__.infHistory, function(hist) {
        birthTotal += hist.birth;
        eatTotal += hist.eatenDeath;
        hungryDeath += hist.hungryDeath;
        return bombDeath += hist.bombDeath;
      });
      write("  総出生回数");
      writeline(indent("" + birthTotal));
      write("  総捕食回数");
      writeline(indent("" + eatTotal));
      write("  総餓死回数");
      writeline(indent("" + hungryDeath));
      write("  総爆撃回数");
      writeline(indent("" + __.info.bombNum));
      write("  総爆撃死回数");
      return writeline(indent("" + bombDeath));
    }
  }
};

drawMenu = function() {
  var drawMenuItem;
  drawMenuItem = function(menuitem) {
    var pt, sz;
    pt = menuitem.point;
    sz = params.menuTileSize;
    if (menuitem.checked) {
      __.ctxWrap.ctx.fillRect(pt.x - sz / 2 + 3, pt.y - sz / 2 + 3, sz - 6, sz - 6);
    }
    return __.ctxWrap.drawImage(images[menuitem.id], menuitem.point);
  };
  return each(_menu, drawMenuItem);
};

drawMissions = function() {
  var ctx, drawmission, indent, lineCount, startX, write, writeline;
  __.ctxWrap.ctx.font = "13px 'ＭＳ ゴシック'";
  indent = function(str) {
    return "                " + str;
  };
  ctx = __.ctxWrap.ctx;
  startX = params.scrLeft + 10;
  lineCount = 1;
  writeline = function(str) {
    return ctx.fillText(str, startX, 19 * lineCount++ + params.marginTop);
  };
  write = function(str) {
    return ctx.fillText(str, startX, 19 * lineCount + params.marginTop);
  };
  writeline("ミッション");
  drawmission = function(mission) {
    if (__.missionFlag[mission.name]) {
      write("■");
    } else {
      write("□");
    }
    write("   " + mission.name);
    return writeline(indent("" + (mission.getCondition())));
  };
  return each(_missions, function(mission) {
    return drawmission(mission);
  });
};

drawMessage = function() {
  __.ctxWrap.ctx.font = "21px 'ＭＳ ゴシック'";
  if (__.currentMessage) {
    __.currentMessage.time++;
    __.ctxWrap.ctx.fillText(__.currentMessage.str, params.screanWidth - 6 * __.currentMessage.time, params.screanHeight - 11);
    if (__.currentMessage.time > 250) {
      return __.currentMessage = null;
    }
  } else if (__.message.length > 0) {
    __.currentMessage = __.message[0];
    return __.message = __.message.slice(1, __.message.length);
  }
};

pushMessage = function(str) {
  var message;
  message = {
    str: str,
    time: 0
  };
  return __.message.push(message);
};

drawImpl = function() {
  var ctxWrap, eff, id, inf, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
  ctxWrap = __.ctxWrap;
  for (_i = 0, _len = _drawOrder.length; _i < _len; _i++) {
    id = _drawOrder[_i];
    _ref = __.livingInfLists[id];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      inf = _ref[_j];
      ctxWrap.drawImage(images[inf.type], inf.point);
    }
  }
  if (params.pick) {
    ctxWrap.drawImage(images[params.pick.type], params.pick.point);
  }
  _ref1 = __.objects;
  for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
    obj = _ref1[_k];
    obj.draw();
  }
  _ref2 = __.effects;
  _results = [];
  for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
    eff = _ref2[_l];
    _results.push(eff.draw());
  }
  return _results;
};

update = function() {
  var eff, nextEffects, nextObjects, obj, _i, _j, _len, _len1, _ref, _ref1;
  checkFlag();
  if (!params.stop) {
    __.info.time++;
    moveInfs();
  }
  nextObjects = [];
  _ref = __.objects;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    obj = _ref[_i];
    if (obj.update()) {
      nextObjects.push(obj);
    }
  }
  __.objects = nextObjects;
  nextEffects = [];
  _ref1 = __.effects;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    eff = _ref1[_j];
    if (eff.update()) {
      nextEffects.push(eff);
    }
  }
  __.effects = nextEffects;
  updateClickEvent();
  if (__.livingInfLists) {
    return checkMission();
  }
};

updateClickEvent = function() {
  var i, inf, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2;
  if (__.mouse.clicked) {
    updateMenu();
    __.mouse.clicked = false;
    if (__.mouse.pt.y > params.scrFloor || __.mouse.pt.x > params.scrRight) {
      return;
    }
    if (params.clickType === "bomb") {
      __.info.bombNum++;
      if (params.pick) {
        params.pick.picked = false;
        params.pick = null;
      }
      for (i = _i = 1; _i <= 4; i = ++_i) {
        __.effects.push(createEffect(__.mouse.pt));
      }
      _ref = __.livingInfaninos;
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        inf = _ref[_j];
        if (getDistance(inf.point, __.mouse.pt) < 30) {
          if (inf.type !== "tt") {
            killInf(inf, "bomb");
            inf.type = "tt";
            inf.flag = true;
            inf.life = 0;
          }
        }
      }
    } else if (params.clickType === "pincettes") {
      if (params.pick) {
        params.pick.picked = false;
        params.pick = null;
      } else {
        _ref1 = __.livingInfaninos;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          inf = _ref1[_k];
          if (getDistance(inf.point, __.mouse.pt) < 3) {
            inf.picked = true;
            params.pick = inf;
            break;
          }
        }
        if (!inf.picked) {
          _ref2 = __.livingInfaninos;
          for (_l = 0, _len2 = _ref2.length; _l < _len2; _l++) {
            inf = _ref2[_l];
            if (getDistance(inf.point, __.mouse.pt) < 10) {
              inf.picked = true;
              params.pick = inf;
              break;
            }
          }
        }
      }
    }
  }
};

checkFlag = function() {
  var inf, nums, _i, _len, _ref;
  __.livingInfaninos = [];
  if (__.livingInfLists === null) {
    __.livingInfLists = {};
  }
  __.deadInfs = [];
  nums = {};
  each(typeDef, function(typeParams) {
    if (__.livingInfLists[typeParams.id]) {
      nums[typeParams.id] = __.livingInfLists[typeParams.id].length;
    } else {
      nums[typeParams.id] = -1;
    }
    return __.livingInfLists[typeParams.id] = [];
  });
  __.energy = 0;
  _ref = __.infaninos;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    inf = _ref[_i];
    __.energy += inf.energy;
    if (inf.picked) {
      inf.point.x = __.mouse.pt.x;
      inf.point.y = __.mouse.pt.y;
    } else if (inf.flag) {
      __.livingInfaninos.push(inf);
      __.livingInfLists[inf.type].push(inf);
    } else {
      __.deadInfs.push(inf);
    }
  }
  if (__.energy < params.infaninos_max) {
    __.livingInfaninos[0].energy++;
  }
  each(typeDef, function(typeParams) {
    if (nums[typeParams.id] === 0 && __.livingInfLists[typeParams.id].length > 0) {
      pushMessage("" + typeParams.name + "が発生しました！");
    } else if (nums[typeParams.id] > 0 && __.livingInfLists[typeParams.id].length === 0) {
      pushMessage("" + typeParams.name + "が全滅しました・・・");
    }
  });
};

moveInfs = function() {
  var inf, _i, _len, _ref;
  _ref = __.livingInfaninos;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    inf = _ref[_i];
    moveInf(inf);
  }
};

moveInf = function(inf) {
  var eatList, eatMenu, eatParam, eated, evol, evoluated, index, moveParam, pt, target, typeParams, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;
  typeParams = typeDef[inf.type];
  pt = inf.point;
  moveParam = typeParams.moveDef;
  inf.dArg = rnd(23) * rndPL() / 200 * moveParam.dArg + inf.dArg * 9 / 10;
  inf.arg += inf.dArg;
  if (inf.arg > Math.PI) {
    inf.arg - Math.PI;
  }
  if (inf.arg < -Math.PI) {
    inf.arg + Math.PI;
  }
  movePt(pt, inf.arg, 0.4 * moveParam.speed);
  if (pt.x < params.scrLeft) {
    pt.x = params.scrLeft;
  }
  if (pt.x > params.scrRight) {
    pt.x = params.scrRight;
  }
  if (pt.y < params.scrTop) {
    pt.y = params.scrTop;
  }
  if (pt.y > params.scrFloor) {
    pt.y = params.scrFloor;
  }
  eatParam = typeParams.eatDef;
  eatList = typeParams.eat;
  eated = false;
  if (inf.energy < eatParam.hungry) {
    for (_i = 0, _len = eatList.length; _i < _len; _i++) {
      eatMenu = eatList[_i];
      if (inf.life % eatMenu.probability !== 0) {
        continue;
      }
      if (eated) {
        break;
      }
      _ref = __.livingInfLists[eatMenu.id];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        target = _ref[_j];
        if (eated) {
          break;
        }
        if (getDistance(inf.point, target.point) < eatParam.range) {
          if (eatMenu.type === "mos") {
            inf.energy += 1;
            target.energy -= 1;
            eated = true;
            if (target.energy <= 0) {
              killInf(target, "eaten");
            }
          } else {
            killInf(target, "eaten");
            inf.energy += target.energy;
            target.energy = 0;
            eated = true;
            _ref1 = typeDef[target.type].evolution;
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              evol = _ref1[_k];
              if (evol.type !== "eaten") {
                continue;
              }
              if (rnd(evol.probability) === 1) {
                target.flag = true;
                target.type = evol.id;
                target.energy += typeDef[evol.id].energy;
                inf.energy -= typeDef[evol.id].energy;
                target.life = 0;
              }
            }
          }
        }
      }
    }
  } else {
    if (typeParams.breed.type === "split") {
      if (inf.life > 5 && inf.life % typeParams.breed.time === 0) {
        bearInf(inf);
      }
    }
  }
  inf.life++;
  if (inf.life > typeParams.lifeTime) {
    if (eatParam.hungry === 0) {
      inf.life = 0;
      evoluated = false;
      _ref2 = typeParams.evolution;
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        evol = _ref2[_l];
        if (evolInf(inf, evol)) {
          break;
        }
      }
    } else if (inf.energy >= eatParam.hungry && typeParams.breed.type !== "non") {
      inf.life = 0;
      evoluated = false;
      _ref3 = typeParams.evolution;
      for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
        evol = _ref3[_m];
        if (evolInf(inf, evol)) {
          evoluated = true;
          break;
        }
      }
      if (!evoluated) {
        bearInf(inf);
      }
    } else {
      killInf(inf, "hungry");
      inf.flag = true;
      inf.type = "tt";
      index = 0;
      while (inf.energy > 1) {
        if (typeParams.decompose.length > 0) {
          inf.type = typeParams.decompose[index];
          index = (index + 1) % typeParams.decompose.length;
        }
        bearInf(inf);
      }
      setInfType(inf, inf.type);
    }
  }
};

updateMenu = function() {
  var checkPlayer, checkView, i, resetclickevent, resetplayer, resetview, storage, time, _i, _j, _ref, _ref1;
  resetplayer = function() {
    _menu.play.checked = false;
    _menu.hispeed.checked = false;
    return _menu.stop.checked = false;
  };
  checkPlayer = function(item, predicade) {
    if (hittestRectangle(__.mouse.pt, _menu[item].point, params.menuTileSize / 2)) {
      if (_menu[item].checked) {
        _menu[item].index++;
      }
      resetplayer();
      _menu[item].checked = true;
      params.stop = false;
      return predicade();
    }
  };
  checkPlayer("play", function() {
    return params.interval = 30;
  });
  checkPlayer("hispeed", function() {
    return params.interval = 3;
  });
  checkPlayer("stop", function() {
    return params.stop = true;
  });
  resetclickevent = function() {
    _menu.bomb.checked = false;
    return _menu.pincettes.checked = false;
  };
  if (hittestRectangle(__.mouse.pt, _menu.pincettes.point, params.menuTileSize / 2)) {
    params.clickType = "pincettes";
    resetclickevent();
    _menu.pincettes.checked = true;
  }
  if (hittestRectangle(__.mouse.pt, _menu.bomb.point, params.menuTileSize / 2)) {
    params.clickType = "bomb";
    resetclickevent();
    _menu.bomb.checked = true;
  }
  if (hittestRectangle(__.mouse.pt, _menu.save.point, params.menuTileSize / 2)) {
    if (checkWebstorage()) {
      if (confirm("SAVEしますか？")) {
        storage = localStorage;
        storage.setItem("bombNum", __.info.bombNum);
        storage.setItem("time", __.info.time);
        each(__.infHistory, function(hst) {
          return storage.setItem("hst" + hst.id, JSON.stringify(hst));
        });
        storage.setItem("time", __.info.time);
        storage.setItem("missionFlag", JSON.stringify(__.missionFlag));
        for (i = _i = 0, _ref = params.infaninos_max; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          storage.setItem("inf" + i, JSON.stringify(__.infaninos[i]));
        }
        alert("SAVEしました！");
      }
    }
  }
  if (hittestRectangle(__.mouse.pt, _menu.load.point, params.menuTileSize / 2)) {
    if (checkWebstorage()) {
      if (confirm("LOADしますか？")) {
        storage = localStorage;
        time = storage.getItem("time");
        if (time != null) {
          __.info.time = storage.getItem("time");
          __.info.bombNum = storage.getItem("bombNum");
          __.missionFlag = storage.getItem("missionFlag");
          if (__.missionFlag) {
            __.missionFlag = JSON.parse(__.missionFlag);
          } else {
            __.missionFlag = {};
          }
          each(__.infHistory, function(hst) {
            return __.infHistory[hst.id] = JSON.parse(storage.getItem("hst" + hst.id));
          });
          for (i = _j = 0, _ref1 = params.infaninos_max; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            __.infaninos[i] = JSON.parse(storage.getItem("inf" + i));
          }
          alert("LOADしました！");
          __.livingInfLists = null;
        } else {
          alert("SAVEデータがありません");
        }
      }
    }
  }
  resetview = function() {
    _menu.data.checked = false;
    _menu.watch.checked = false;
    return _menu.mission.checked = false;
  };
  checkView = function(item) {
    if (hittestRectangle(__.mouse.pt, _menu[item].point, params.menuTileSize / 2)) {
      if (_menu[item].checked) {
        _menu[item].index++;
      }
      resetview();
      return _menu[item].checked = true;
    }
  };
  checkView("data");
  checkView("watch");
  return checkView("mission");
};

checkWebstorage = function() {
  if (typeof sessionStorage !== 'undefined') {
    return true;
  } else {
    alert("ご利用のブラウザではセーブ・ロード機能は使えません");
    return false;
  }
};

checkMission = function() {
  var histrory, lists;
  lists = __.livingInfLists;
  histrory = __.infHistory;
  checkMissionOf("生物博士", function() {
    return every(histrory, function(hst) {
      return hst.birth > 0;
    });
  });
  checkMissionOf("爆撃魔神", function() {
    var bombDeath;
    bombDeath = 0;
    each(histrory, function(hist) {
      return bombDeath += hist.bombDeath;
    });
    return bombDeath >= 1000;
  });
  checkMissionOf("ベテラン", function() {
    return __.info.time > 100000;
  });
  checkMissionOf("森林浴", function() {
    return lists["ki"].length >= 50;
  });
  checkMissionOf("サバンナ", function() {
    return lists["ks"].length >= 200 && lists["on"].length >= 5;
  });
  checkMissionOf("お花畑", function() {
    return lists["hn"].length >= 100;
  });
  checkMissionOf("鳥天国", function() {
    return lists["tr"].length >= 20 && lists["kt"].length >= 10;
  });
  checkMissionOf("毒の大地", function() {
    return lists["db"].length >= 300;
  });
  checkMissionOf("奈良", function() {
    return lists["sd"].length >= 30;
  });
  checkMissionOf("吸血地獄", function() {
    return lists["ka"].length >= 50;
  });
  checkMissionOf("海辺の生物", function() {
    return lists["yk"].length > 0 && lists["km"].length > 0 && lists["hd"].length > 0;
  });
  checkMissionOf("緑一色", function() {
    var checkExist, existInfList;
    existInfList = filter(lists, function(list) {
      return list.lenght > 0;
    });
    if (existInfList.lenght === 6) {
      checkExist = function(id) {
        return lists[id].length > 0;
      };
      return every(["sb", "sm", "ks", "km", "hb"], checkExist);
    }
    return false;
  });
  checkMissionOf("多様性", function() {
    var existInfList;
    existInfList = filter(lists, function(list) {
      return list.lenght > 0;
    });
    return existInfList.length >= 10;
  });
  checkMissionOf("虫イーター", function() {
    return histrory["nm"].eatenDeath + histrory["sm"].eatenDeath > 200;
  });
  checkMissionOf("殻割名人", function() {
    return histrory["yk"].eatenDeath >= 1000;
  });
  checkMissionOf("森林伐採", function() {
    return histrory["ki"].eatenDeath >= 500;
  });
  checkMissionOf("プロポリス", function() {
    return histrory["ht"].eatenDeath >= 10;
  });
  checkMissionOf("高級食材", function() {
    return histrory["kk"].eatenDeath >= 1;
  });
  checkMissionOf("大好物", function() {
    return histrory["sa"].eatenDeath >= 1;
  });
  return checkMissionOf("命の源", function() {
    return histrory["nb"].birth >= 2000000;
  });
};

checkMissionOf = function(id, chekPredicade) {
  if (!__.missionFlag[id]) {
    if (chekPredicade()) {
      pushMessage("ミッション【" + id + "】を達成しました");
      return __.missionFlag[id] = true;
    }
  }
};

createEffect = function(pt) {
  var newPt, result, timer;
  timer = 8;
  result = {};
  newPt = {
    x: pt.x,
    y: pt.y
  };
  result.update = function() {
    newPt.x += rnd(5) - rnd(5);
    newPt.y += rnd(5) - rnd(5);
    return timer--;
  };
  result.draw = function() {
    return __.ctxWrap.circle(newPt, 5 + rnd(25));
  };
  return result;
};

bearInf = function(inf) {
  var typeParams;
  typeParams = typeDef[inf.type];
  if (__.deadInfs.length > 0) {
    if (__.livingInfLists[inf.type].length < 2 * rnd(params.infaninos_max * typeParams.limit)) {
      return createInf(inf.type, inf.point, inf);
    } else {
      return createInfRnd("tt", inf);
    }
  }
};

createInf = function(type, pt, parent) {
  var newInf, typeParams;
  if (__.deadInfs.length > 0) {
    typeParams = typeDef[type];
    newInf = __.deadInfs.pop();
    setInfType(newInf, type);
    parent.energy -= typeParams.energy;
    newInf.energy += typeParams.energy;
    newInf.point.x = pt.x + rnd(typeParams.breed.range) - rnd(typeParams.breed.range);
    return newInf.point.y = pt.y + rnd(typeParams.breed.range) - rnd(typeParams.breed.range);
  }
};

createInfRnd = function(type, parent) {
  var newInf;
  if (__.deadInfs.length > 0) {
    newInf = __.deadInfs.pop();
    return createInf(type, newInf.point, parent);
  }
};

evolInf = function(inf, evol) {
  var num;
  num = 1;
  if (evol.num) {
    num = evol.num;
  }
  if (evol.key && __.livingInfLists[evol.key].length === 0) {
    return false;
  }
  if (num > __.livingInfLists[evol.id].length) {
    if (rnd(evol.probability) === 1) {
      setInfType(inf, evol.id);
    }
  }
  return false;
};

setInfType = function(inf, type) {
  inclimentBirth(type);
  inf.flag = true;
  inf.type = type;
  return inf.life = rnd(50) - rnd(50);
};

inclimentBirth = function(type) {
  __.infHistory[type].birth++;
  if (__.infHistory[type].birth === 100) {
    return pushMessage("" + typeDef[type].name + "の総出生数が100に達しました");
  } else if (__.infHistory[type].birth === 1000) {
    return pushMessage("" + typeDef[type].name + "の総出生数が1000に達しました");
  } else if (__.infHistory[type].birth === 10000) {
    return pushMessage("" + typeDef[type].name + "の総出生数が10000に達しました");
  } else if (__.infHistory[type].birth === 100000) {
    return pushMessage("" + typeDef[type].name + "の総出生数が100000に達しました");
  }
};

killInf = function(inf, deathType) {
  var hst;
  inf.flag = false;
  hst = __.infHistory[inf.type];
  if (deathType === "hungry") {
    return hst.hungryDeath++;
  } else if (deathType === "eaten") {
    return hst.eatenDeath++;
  } else if (deathType === "bomb") {
    return hst.bombDeath++;
  }
};

gameLoop = function() {
  update();
  return draw();
};
