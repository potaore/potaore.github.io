// Generated by CoffeeScript 1.6.3
var GeneManager, calc, cons, distance, each, evaluator, filter, indexOf, map, mix, mng, newMng, points, random, sum, swap,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

each = _.each;

map = _.map;

random = _.random;

sum = _.reduce;

indexOf = _.indexOf;

filter = _.filter;

swap = function(array, i, j) {
  var _ref;
  return _ref = [array[j], array[i]], array[i] = _ref[0], array[j] = _ref[1], _ref;
};

mix = function(ary, num) {
  var _i, _results;
  each((function() {
    _results = [];
    for (var _i = 1; 1 <= num ? _i <= num : _i >= num; 1 <= num ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this), function() {
    return swap(ary, random(ary.length - 1), random(ary.length - 1));
  });
  return ary;
};

distance = function(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};

cons = {
  min: 0,
  max: 299
};

GeneManager = (function() {
  function GeneManager(num, generator) {
    this.getBestEval = __bind(this.getBestEval, this);
    this.getBestGene = __bind(this.getBestGene, this);
    var _i, _results;
    this.genes = map((function() {
      _results = [];
      for (var _i = 1; 1 <= num ? _i <= num : _i >= num; 1 <= num ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), function() {
      return {
        gene: generator(),
        evaluation: 0
      };
    });
    this.survivors = this.genes;
  }

  GeneManager.prototype.evaluate = function(evaluator) {
    return each(this.genes, function(gene) {
      return gene.evaluation = evaluator(gene.gene);
    });
  };

  GeneManager.prototype.next = function(num, match, nextNum) {
    var main, newgenes, rnd, _i, _results,
      _this = this;
    this.genes = _.sortBy(this.genes, function(gene) {
      return gene.evaluation;
    });
    this.survivors = this.genes.slice(0, num);
    rnd = function() {
      return _this.survivors[random(0, _this.survivors.length - 1)].gene;
    };
    main = function() {
      return _this.survivors[random(0, parseInt(_this.survivors.length / 3))].gene;
    };
    newgenes = map((function() {
      _results = [];
      for (var _i = 0; 0 <= nextNum ? _i < nextNum : _i > nextNum; 0 <= nextNum ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this), function() {
      return {
        gene: match(main(), rnd()),
        evaluation: 0
      };
    });
    return this.genes = newgenes;
  };

  GeneManager.prototype.getBestGene = function() {
    return this.survivors[0].gene;
  };

  GeneManager.prototype.getBestEval = function() {
    return this.survivors[0].evaluation;
  };

  return GeneManager;

})();

evaluator = function(order) {
  var func, _i, _ref, _results;
  func = function(memo, i) {
    var p1, p2;
    p1 = points[order[i]];
    p2 = points[order[(i + 1) % order.length]];
    return memo + distance(p1, p2);
  };
  return sum((function() {
    _results = [];
    for (var _i = 0, _ref = order.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this), func, 0);
};

mng = null;

points = null;

newMng = function(tNum, geneNum) {
  var gen, _i, _results;
  points = map((function() {
    _results = [];
    for (var _i = 1; 1 <= tNum ? _i <= tNum : _i >= tNum; 1 <= tNum ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this), function() {
    return {
      x: random(cons.min, cons.max),
      y: random(cons.min, cons.max)
    };
  });
  gen = function() {
    var temp, _j, _results1;
    return temp = mix((function() {
      _results1 = [];
      for (var _j = 0; 0 <= tNum ? _j < tNum : _j > tNum; 0 <= tNum ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this), tNum * 5);
  };
  mng = new GeneManager(geneNum, gen);
  return draw(mng.getBestGene());
};

calc = function(generationNum, mutation, svNum, nextNum) {
  var match, next;
  match = function(gene1, gene2) {
    var index, len, newGen, revRoute, swapRoute, x, y;
    newGen = gene1.slice(0);
    len = gene1.length;
    index = random(parseInt(len / 2), len - 1);
    swapRoute = function(gene, x, y) {
      var a1, a2, a3, a4, _ref, _ref1;
      if (x === y) {
        return gene;
      }
      if (x > y) {
        _ref = [y, x], x = _ref[0], y = _ref[1];
      }
      _ref1 = [gene.slice(0, x + 1), gene.slice(x + 1, y), [gene[y]], gene.slice(y + 1, len)], a1 = _ref1[0], a2 = _ref1[1], a3 = _ref1[2], a4 = _ref1[3];
      return a1.concat(a3).concat(a2).concat(a4);
    };
    revRoute = function(gene, x, y) {
      var a1, a2, a3, _ref, _ref1;
      if (x === y) {
        return gene;
      }
      if (x > y) {
        _ref = [y, x], x = _ref[0], y = _ref[1];
      }
      _ref1 = [gene.slice(0, x), gene.slice(x, y), gene.slice(y, len)], a1 = _ref1[0], a2 = _ref1[1], a3 = _ref1[2];
      return a1.concat(a2.reverse()).concat(a3);
    };
    while (index < len - 1) {
      x = indexOf(gene1, gene2[random(len - 2)]);
      y = indexOf(gene1, gene2[random(len - 2)]);
      newGen = swapRoute(newGen, x, y);
      index++;
    }
    if (random(0, 10) === 0) {
      newGen = newGen.slice(1, len).concat([newGen[0]]);
    }
    while (random(1, 1000) <= mutation) {
      if (random(0, 2) === 0) {
        newGen = swapRoute(newGen, random(len - 1), random(len - 1));
      } else if (random(0, 1) === 0) {
        swap(newGen, random(len - 1), random(len - 1));
      } else {
        newGen = revRoute(newGen, random(len - 1), random(len - 1));
      }
    }
    return newGen;
  };
  next = function(left) {
    return function() {
      if (left <= 0) {
        console.log(mng.getBestEval());
        disable(false);
        return;
      }
      mng.evaluate(evaluator);
      mng.next(svNum, match, nextNum);
      draw(mng.getBestGene());
      return setTimeout(next(left - 1), 1);
    };
  };
  return setTimeout(next(generationNum), 1);
};
